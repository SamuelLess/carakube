"""
Vulnerability State Management

Manages the state of vulnerabilities through their lifecycle:
- untouched: Initial state, no action taken
- in_processing: Fix is being generated
- pr_available: PR has been created
"""

import json
from pathlib import Path
from typing import Dict, Any, Literal, Optional
from datetime import datetime, timezone

VulnerabilityState = Literal["untouched", "in_processing", "pr_available"]

STATE_FILE = Path("/app/scanner_output/vulnerability_states.json")


def _ensure_state_file() -> None:
    """Ensure the state file exists with valid JSON."""
    if not STATE_FILE.exists():
        STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
        STATE_FILE.write_text("{}")


def load_states() -> Dict[str, Dict[str, Any]]:
    """
    Load all vulnerability states from the JSON file.

    Returns:
        Dictionary mapping vulnerability IDs to their state info:
        {
            "vuln-abc123": {
                "state": "pr_available",
                "pr_url": "https://github.com/...",
                "updated_at": "2025-11-22T10:00:00Z"
            }
        }
    """
    _ensure_state_file()
    try:
        with open(STATE_FILE, "r") as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return {}


def save_states(states: Dict[str, Dict[str, Any]]) -> None:
    """
    Save vulnerability states to the JSON file.

    Args:
        states: Dictionary of vulnerability states
    """
    _ensure_state_file()
    with open(STATE_FILE, "w") as f:
        json.dump(states, f, indent=2)


def get_vulnerability_state(vuln_id: str) -> Dict[str, Any]:
    """
    Get the state of a specific vulnerability.

    Args:
        vuln_id: The vulnerability ID

    Returns:
        State info for the vulnerability, defaults to "untouched" if not found
    """
    states = load_states()
    if vuln_id in states:
        return states[vuln_id]

    return {"state": "untouched", "pr_url": None, "updated_at": None}


def update_vulnerability_state(
    vuln_id: str, state: VulnerabilityState, pr_url: Optional[str] = None
) -> Dict[str, Any]:
    """
    Update the state of a vulnerability.

    Args:
        vuln_id: The vulnerability ID
        state: The new state ("untouched", "in_processing", "pr_available")
        pr_url: Optional PR URL (required for "pr_available" state)

    Returns:
        The updated state info
    """
    states = load_states()

    state_info = {
        "state": state,
        "pr_url": pr_url,
        "updated_at": datetime.now(timezone.utc).isoformat(),
    }

    states[vuln_id] = state_info
    save_states(states)

    return state_info


def get_all_states() -> Dict[str, Dict[str, Any]]:
    """
    Get all vulnerability states.

    Returns:
        Dictionary of all vulnerability states
    """
    return load_states()


def reset_state(vuln_id: str) -> None:
    """
    Reset a vulnerability state to untouched.

    Args:
        vuln_id: The vulnerability ID
    """
    update_vulnerability_state(vuln_id, "untouched", pr_url=None)


def delete_state(vuln_id: str) -> None:
    """
    Delete a vulnerability state entirely.

    Args:
        vuln_id: The vulnerability ID
    """
    states = load_states()
    if vuln_id in states:
        del states[vuln_id]
        save_states(states)
